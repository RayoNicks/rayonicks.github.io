---
layout: post
title: 《汇编器与加载器》绪论
categories: Reading
tags: system
---

# 绪论

我们首先要给汇编器下个定义，不幸的是计算机科学不像数学一样是一门严谨的学科，所以很多定义并不精确。我最喜欢关于汇编器的定义应该是这个：

汇编器的功能是将符号语言表示的源指令逐条翻译为机器可以识别的目标指令。

>An assembler is a translator that translates source instructions (in symbolic language) into target instructions(in machine language), on a one to one basis.

注意，每一条源指令只翻译为一条目标指令。

这个定义的优点在于清楚的说明了汇编器的翻译过程，不过还是不太准确，因为汇编器的功能并不只限于翻译，还为编写程序提供了很多便利——也就是通常说的指令（也包括伪指令）。本书将在第3章和第4章中讨论所有重要的指令。

汇编器的另一个定义为：

汇编器的功能是将面向机器的语言翻译为机器语言。

>An assembler is a translator that translates a machineoriented language into machine language.

这个定义借鉴了编译器的定义：编译器的功能是翻译面向问题的语言，或者机器无关的语言。相比于前者，这个定义没有提及逐条翻译，而这其实是汇编器最重要的特点之一。

学习汇编器的原因在于汇编器的工作过程反映了机器的体系结构，因此汇编语言也非常依赖于机器的内部组成。体系结构方面的特性，例如内存字大小、数制系统、编码方式、索引寄存器、通用寄存器，影响着汇编语言的编写方式和汇编器的翻译方式。这一事实说明了为什么还有研究汇编器的必要、为什么汇编语言相关课程依然是计算机学科的必修课程。

世界上第一个汇编器是assemble-go，它的功能仅仅是将代码汇编到内存中然后开始执行。不过人们很快的就意识到，链接是一个非常重要的功能。计算机科学的先驱们很早就提出了库（routine library）的概念，所以它们需要汇编器可以定位、加载和将其链接到主程序中，汇编器因此而得名（准确来说应该要组装器）[[4](#Reference)]。如今，汇编器只保留了翻译的功能，并且一次只翻译一个汇编程序，而定位、加载和链接等其它功能由加载器负责。

现代汇编器包含两种输入和两种输出，第一种输入是触发汇编器的命令，命令中一般包含需要汇编的源代码文件，还包含一些在如何进行汇编的信息，例如：

- 目标文件和列表文件的名字
- 是否在终端中打印列表文件
- 遇到错误是否继续进行汇编
- 不打印但是保存列表文件
- 是否启用宏
- 符号表的大小提示

本书后面将会逐一解释这些术语。下面给出了一个启用宏和的VAX汇编器命令：

```
MACRO /SHOW=MEB /LIST /DEBUG ABC
```

这条命令启动了汇编器程序，指出了源代码文件名为abc.mar（后缀被省略了）、在扩展宏时要显示二进制行、要创建列表文件、在汇编的过程中要生成调试信息。

再看一个MASM汇编器的例子：

```
MASM /d /Dopt=5 /MU /V
```

这条命令向汇编器传递了一个值为`5`的`opt`变量，并且告诉汇编器要将源代码文件中的所有字母转换为大写，同时在列表文件中要包含一些额外的信息。

汇编器的第二个输入是源文件，包含一系列符号化的指令和伪指令。汇编器会将这些指令逐条翻译为机器指令，而对于伪指令，汇编器会用特定的方式去解释它们。现代汇编器一般支持上百条伪指令，从最简单的`ORG`（用于指出起始地址），到复杂的`MACRO`。本书第3章和第4章将会介绍常见的伪指令。

汇编器的第一个输出是目标文件，这也是最重要的输出，它包含了将要被机器执行的机器指令。目标文件是汇编器和加载器系统中重要的组成部分，因为它实现了一次汇编后的多次运行。此外，目标文件中也可以包含汇编器需要传递给加载器的一些信息，从而选择程序的加载方式，这些信息可以被称为加载器伪指令，本书第3章和第7章将会讨论加载器伪指令。汇编器也可以不输出目标文件。

汇编器的第二个输出是列表文件，源文件的中的每一行产生列表文件的规则为：

- 定位计数器（The Location Counter）
- 源代码行号
- 机器指令
- 伪指令

一般列表文件生成后会被输出，然后就被删掉了，所以程序员也可以选择不生成或者不打印列表文件。有一些伪指令是针对列表文件的，比如可以跳过生成列表文件的一部分，是否打印页首部，控制宏的展开等。

列表文件通常包含交叉引用信息，存在例外的是MASM汇编器将交叉引用信息生成到了单独的文件中，并且要通过额外的程序来查看交叉引用信息。交叉引用信息包含程序中所有符号被定义的位置和被引用的位置。

*练习1 为什么需要跳过生成列表文件的一部分，或者不打印列表文件？*

前面提到的assemble-go汇编器是不生成目标文件的，它只生成机器指令和列表文件。assemble-go是一遍汇编器，理论上是可以生成目标文件的，只是目标文件中使用的都是绝对地址，这就降低了目标文件的灵活性。

现在很多汇编器都是两遍汇编器，它们产生的目标文件是可以被重定位的，因此可以被链接和加载。

顾名思义，加载器的作用是将程序加载到内存中，不过现代加载器的作用远不止于此，它们的主要任务包括加载、重定位、链接和启动程序。现代加载器可以读取多个目标文件，将它们逐个加载到内存中，重定位每个目标文件，最终将所有单独的目标文件链接成一个可执行模块，并从程序入口点开始执行。这样的加载器有几个优点，其中最重要的优点是能够编写和组装包含多个独立部分的程序。

将一个大型程序拆分成多个部分是有利的，因为每一部分可以由不同的程序员编写，每个程序员只关注自己的部分就可以了，甚至不同的部分都可以使用不同的语言编写。通常情况下，主程序是由高级语言编写的，其余例程用汇编语言编写。每一部分被分别汇编（编译），产生多个目标文件，所以汇编器（编译器）只能看到一部分，不能看到整个程序，只有加载器可以看到所有的部分，并将这些部分组装成一个完整的程序。同时汇编器在也是不知道输入源程序是完整的程序还是只是一部分的，所以它假设程序从零地址开始，并基于该假设进行汇编。在加载器加载每一部分之前，加载器会根据当前可用的内存区域和前一个加载的对象文件的地址确定当前部分的开始地址，然后加载程序，确保所有的指令装入正确的内存地址。这个调整程序中内存地址的过程称为重定位。

由于汇编器一次只处理一个程序，因此它是不能链接多个程序的。当汇编器汇编主程序的源文件时，它是不知道其它的源文件中可能包含了主程序中需要调用的例程的，结果就是它不知道调用指令的目标地址是什么，这样产生出的目标文件中就会包含一些无法填充的洞（holes）。但是由于加载器是可以看到所有的源程序的，所以它会填充这些洞中的值。这个过程称为链接。

在程序可以被运行之前，需要对其进行翻译（汇编和编译）、加载、重定位和链接，这些工作由汇编器（编译器）和加载器分别进行。同时具备两种功能的汇编加载系统（dual assmebler-loader systems）也是存在的。和上述过程存在区别的就是解释执行的程序，例如BASIC和APL，这些语言编写的程序的运行需要解释器，而不是汇编器和加载器。划分汇编器和加载器的首要原因在于可以分别开发程序的不同部分，详细的原因在这里不予给出，不过我们在这里会按照重要性给出一些汇编加载系统的优点：

- 程序可以被划分为多个部分进行分别开发，甚至使用不同的语言
- 汇编器的体积主要取决于符号表和宏表的大小，分别汇编源程序的每一部分可以使汇编器的体积很小
- 如果汇编很慢的话，那么当程序被修改后只重新汇编修改的一部分就可以了，不过事实一般是汇编很快，加载很慢
- 将汇编和加载分开使得加载器可以直接从库中加载汇编后的例程，这通常被认为是一个优点，但其实并不是这样子的，因为如果库中就是源代码的话也是可以的，而且源代码的体积通常会比目标文件的体积小

上面第二条感觉有些牵强，原文：

>It keeps the assembler small. This is an important advantage. The size of the assembler depends on the size of its internal tables (especially the symbol table and the macro definition table). An assembler designed to assemble large programs is large because of its large tables. Separate assembly makes it possible to assemble very large programs with a small assembler.

# 参考文献 {#Reference}

```ref
4. Wilkes, M. V., D. J. Wheeler, and S. Gill, The Preparation of Programs for an Electronic Digital Computer. Reading, MA.: Addison-Wesley, 1951.
```
